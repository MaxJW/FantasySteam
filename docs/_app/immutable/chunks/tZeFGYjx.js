import{_ as R}from"./PPVm8Dsz.js";import{c as G,b as w,q as I,o as C,g as B,a as L,d as v}from"./CVdz52PO.js";let m=null,u=null;async function d(){if(m&&u)return{gamesData:m,gamesById:u};try{const a=(await R(async()=>{const{default:t}=await import("./BAsd2ghB.js");return{default:t}},[],import.meta.url)).default;return m=a,u=new Map(a.games.map(t=>[t.id,t])),{gamesData:m,gamesById:u}}catch{return m=null,u=null,{gamesData:{games:[]},gamesById:new Map}}}function F(){m=null,u=null}const E=3,T=500;let f=null;async function S(a=0){try{const t=await L(v(w,"meta","scores"));return t.exists()?t.data().scores??{}:{}}catch{if(a<E-1){const e=T*Math.pow(2,a);return await new Promise(s=>setTimeout(s,e)),S(a+1)}return{}}}function h(){return f||(f=S().catch(a=>(f=null,{}))),f}function H(){f=null}async function Y(a){const{gamesById:t}=await d(),e=t.get(a)??null;if(!e)return null;const s=await h();return{...e,id:a,score:s[a]??null}}async function A(){const{gamesData:a}=await d();return[...new Set(a.games.map(e=>e.releaseDate?.slice(0,4)).filter(e=>!!e&&/^\d{4}$/.test(e)).map(e=>parseInt(e,10)))].sort((e,s)=>s-e)}async function U(a){const{gamesData:t}=await d(),e=String(a),s=new Set;for(const i of t.games)if(i.releaseDate?.startsWith(e))for(const r of i.genres??[])s.add(r);return[...s].sort()}async function M(a,t){const{gamesData:e}=await d(),s=String(a),i=await h();let r=e.games.filter(n=>n.releaseDate?.startsWith(s));return t?.genres?.length&&(r=r.filter(n=>t.genres.some(g=>(n.genres??[]).includes(g)))),r.map(n=>({id:n.id,name:n.name,releaseDate:n.releaseDate??null,coverUrl:n.coverUrl??null,score:i[n.id]??null}))}async function W(a,t,e,s){const i=s?.genres?.length?{genres:s.genres}:void 0;let r=await M(a,i);if(s?.releaseFrom&&(r=r.filter(o=>(o.releaseDate??"")>=s.releaseFrom)),s?.releaseTo&&(r=r.filter(o=>(o.releaseDate??"")<=s.releaseTo)),s?.hideReleased){const o=new Date().toISOString().split("T")[0];r=r.filter(c=>{const l=c.releaseDate??"";return!l||l>o})}if(s?.search?.trim()){const o=s.search.trim().toLowerCase();r=r.filter(c=>c.name.toLowerCase().includes(o))}const n=s?.sortBy??"date",p=(s?.order??"asc")==="asc"?1:-1;r=[...r].sort((o,c)=>{let l=0;if(n==="id")l=(o.id??"").localeCompare(c.id??"");else if(n==="name")l=(o.name??"").localeCompare(c.name??"",void 0,{sensitivity:"base"});else if(n==="date")l=(o.releaseDate??"").localeCompare(c.releaseDate??"");else{const y=o.score??-1/0,D=c.score??-1/0;l=y===D?0:y<D?-1:1}return l*p});const _=r.length;return{games:r.slice(e,e+t),total:_}}async function b(a){const{gamesById:t}=await d();return t.get(a)?.isHidden===!0}async function x(a){const t=G(w,"games",a,"history"),e=I(t,C("date","asc"));return(await B(e)).docs.map(i=>{const r=i.data();return{owners:r.estimatedOwners??0,ownersDelta:r.salesDelta??0,ccu:r.ccu??0,daysSinceRelease:r.daysSinceRelease??0,dailyPoints:r.points??0,date:r.date??i.id}})}async function V(){const{gamesData:a}=await d(),t=new Date().toISOString().split("T")[0];return a.games.filter(e=>!e.isHidden&&e.releaseDate&&e.releaseDate>=t).sort((e,s)=>(e.releaseDate??"").localeCompare(s.releaseDate??"")).map(e=>({...e,id:e.id}))}export{Y as a,W as b,V as c,A as d,U as e,F as f,x as g,b as i,H as r};

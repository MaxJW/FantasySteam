import{q as T,w as U,a as P,b as M,d as S,u as j,e as b,f as d,h as k,i as R,j as z}from"./V1ThnXvC.js";import{D as _,g as K,a as G,b as J,c as Q,d as V}from"./CzOqzXZD.js";import{g as W}from"./DOiIeLCc.js";const g="leagues",B="teams",X="drafts";function w(t){return b(d,g,t)}function F(t,a){return b(d,g,t,B,a)}function Z(t,a){return b(d,g,t,X,a)}async function v(t){const a=await S(w(t));return a.exists()?{id:a.id,...a.data()}:null}async function $(t){const a=T(P(d,g),U("code","==",t.trim().toUpperCase())),s=await M(a);if(s.empty)return null;const e=s.docs[0];return{id:e.id,...e.data()}}async function ft(t){const a=T(P(d,g),U("members","array-contains",t));return(await M(a)).docs.map(e=>({id:e.id,...e.data()}))}async function q(t){return(await M(P(d,g,t,B))).docs.map(s=>({id:s.id,...s.data()}))}async function H(t,a,s){const e=await S(Z(t,J(a,s)));return e.exists()?e.data().status:null}async function I(t,a){for(const s of _)if(await H(t,s,a)==="completed")return!0;return!1}async function tt(t,a){const s={};for(const e of _)s[e]=await H(t,e,a);return s}async function dt(t){const a=await v(t);if(!a)return;const s=await tt(t,a.season),e=K(s,a.season);if(e&&e!==a.currentPhase){const c={currentPhase:e};a.status==="draft"&&(c.status="active"),await j(w(t),c)}}function N(){return{winterPicks:[],summerPicks:[],fallPicks:[],altPicks:[]}}function at(){const t=new Date;return(t.getMonth()===11?t.getFullYear()+1:t.getFullYear()).toString()}const st="League code already in use";async function mt(t,a,s,e,c="My Studio"){const f=s.trim().toUpperCase();if(await $(f))throw new Error(st);const u=b(P(d,g)),l={name:a,code:f,commissionerId:t,settings:e,season:at(),status:"draft",currentPhase:"winter",members:[t],delistedGames:[],createdAt:R()};return await k(u,l),await k(F(u.id,t),{name:c.trim()||"My Studio",picks:N(),score:0,bombAdjustment:0}),u.id}async function gt(t,a,s="My Studio"){const e=await S(w(t));if(!e.exists())throw new Error("League not found");const c=e.data();if(c.members.includes(a))return;if(await I(t,c.season))throw new Error("Cannot join a league that is already in progress.");await j(w(t),{members:[...c.members,a]}),await k(F(t,a),{name:s.trim()||"My Studio",picks:N(),score:0,bombAdjustment:0})}async function pt(t){const a=await v(t);if(!a)throw new Error("League not found");const s=V(a.currentPhase);s?await j(w(t),{currentPhase:s,status:"active"}):await j(w(t),{status:"completed"})}async function wt(t){await z(w(t))}async function et(t,a){const s=await v(t),e=await q(t),c=s?.delistedGames??[],f=new Map,m=new Set;for(const o of e)G(o.picks,c).forEach(n=>m.add(n));const u=new Map;for(const o of m)try{let n=(await W(o)).map(r=>({date:r.date||"",points:r.dailyPoints}));a&&(n=n.filter(r=>r.date&&r.date<=a)),u.set(o,n)}catch{}const l=await M(P(d,"leagues",t,"scoring")),D=new Map;for(const o of l.docs){const i=o.data(),n=i.date??o.id;i.bombAdjustments&&(!a||n<=a)&&D.set(n,i.bombAdjustments)}const A=new Set;u.forEach(o=>{o.forEach(i=>A.add(i.date))});let p=Array.from(A).sort();a&&(p=p.filter(o=>o<=a));for(const o of e)f.set(o.id,new Map);for(let o=0;o<p.length;o++){const i=p[o],n=o>0?p[o-1]:null,r=new Map;for(const h of e){const E=G(h.picks,c);let L=0;for(const C of E){const x=u.get(C)?.find(Y=>Y.date===i);x&&(L+=x.points)}r.set(h.id,L)}const y=D.get(i)??{};for(const h of e){const E=f.get(h.id),L=n?E.get(n)??0:0,C=r.get(h.id)??0,x=y[h.id]??0;E.set(i,L+C+x)}}return f}const nt="seasonResults";function O(t,a){return b(d,g,t,nt,a)}async function ot(t,a){const s=await S(O(t,a));return s.exists()?s.data():null}async function rt(t,a){const s=Q(a),e=await et(t,s),c=await q(t),f=new Set;e.forEach(n=>{n.forEach((r,y)=>f.add(y))});const m=Array.from(f).sort(),u={};for(const n of c){const r=e.get(n.id),y=m[m.length-1];u[n.id]=y&&r?r.get(y)??0:0}const l=[...c].sort((n,r)=>(u[r.id]??0)-(u[n.id]??0)),D={};l.forEach((n,r)=>{D[n.id]=r+1});const A=l.map(n=>({teamId:n.id,data:m.map(r=>e.get(n.id)?.get(r)??0)})),p={finalScores:u,finalRanks:D,graphData:{dates:m,series:A},computedAt:R()},o=O(t,a),i=await S(o);return i.exists()?i.data():(await k(o,{...p,computedAt:R()}),(await S(o)).data())}async function lt(t,a){const s=await ot(t,a);return s||rt(t,a)}export{st as L,v as a,pt as b,mt as c,Z as d,ft as e,tt as f,$ as g,q as h,lt as i,gt as j,et as k,wt as l,dt as s,F as t};

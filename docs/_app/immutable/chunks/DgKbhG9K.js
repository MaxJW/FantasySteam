import{q as U,w as F,a as M,b as L,d as T,u as G,e as E,f as l,h as j,i as B,j as I}from"./O3iSBb2n.js";import{D as H,g as Y,a as R,b as J,c as Q,d as V}from"./nK_5IJdR.js";import{g as N}from"./BnIGv0Ow.js";const k="leagues",_="teams",W="drafts";function D(t){return E(l,k,t)}function O(t,a){return E(l,k,t,_,a)}function X(t,a){return E(l,k,t,W,a)}async function x(t){const a=await T(D(t));return a.exists()?{id:a.id,...a.data()}:null}async function Z(t){const a=U(M(l,k),F("code","==",t.trim().toUpperCase())),n=await L(a);if(n.empty)return null;const c=n.docs[0];return{id:c.id,...c.data()}}async function mt(t){const a=U(M(l,k),F("members","array-contains",t));return(await L(a)).docs.map(c=>({id:c.id,...c.data()}))}async function q(t){return(await L(M(l,k,t,_))).docs.map(n=>({id:n.id,...n.data()}))}async function $(t,a,n){const c=await T(X(t,J(a,n)));return c.exists()?c.data().status:null}async function tt(t,a){for(const n of H)if(await $(t,n,a)==="completed")return!0;return!1}async function at(t,a){const n={};for(const c of H)n[c]=await $(t,c,a);return n}async function ut(t){const a=await x(t);if(!a)return;const n=await at(t,a.season),c=Y(n,a.season);if(c&&c!==a.currentPhase){const d={currentPhase:c};a.status==="draft"&&(d.status="active"),await G(D(t),d)}}function z(){return{winterPicks:[],summerPicks:[],fallPicks:[],altPicks:[]}}function et(){const t=new Date;return(t.getMonth()===11?t.getFullYear()+1:t.getFullYear()).toString()}const st="League code already in use";async function gt(t,a,n,c,d="My Studio"){const u=n.trim().toUpperCase();if(await Z(u))throw new Error(st);const f=E(M(l,k)),p={name:a,code:u,commissionerId:t,settings:c,season:et(),status:"draft",currentPhase:"winter",members:[t],delistedGames:[],createdAt:B()};return await j(f,p),await j(O(f.id,t),{name:d.trim()||"My Studio",picks:z(),score:0,bombAdjustment:0}),f.id}async function pt(t,a,n="My Studio"){const c=await T(D(t));if(!c.exists())throw new Error("League not found");const d=c.data();if(d.members.includes(a))return;if(await tt(t,d.season))throw new Error("Cannot join a league that is already in progress.");await G(D(t),{members:[...d.members,a]}),await j(O(t,a),{name:n.trim()||"My Studio",picks:z(),score:0,bombAdjustment:0})}async function lt(t){const a=await x(t);if(!a)throw new Error("League not found");const n=V(a.currentPhase);n?await G(D(t),{currentPhase:n,status:"active"}):await G(D(t),{status:"completed"})}async function wt(t){await I(D(t))}async function nt(t,a){const n=await x(t),c=await q(t),d=n?.delistedGames??[],u=new Map,g=new Set;for(const e of c)R(e.picks,d).forEach(s=>g.add(s));const f=new Map;for(const e of g)try{let s=(await N(e)).map(r=>({date:r.date||"",points:r.dailyPoints}));a&&(s=s.filter(r=>r.date&&r.date<=a)),f.set(e,s)}catch{}const p=await L(M(l,"leagues",t,"scoring")),w=new Map;for(const e of p.docs){const i=e.data(),s=i.date??e.id;i.bombAdjustments&&(!a||s<=a)&&w.set(s,i.bombAdjustments)}const P=new Set;f.forEach(e=>{e.forEach(i=>P.add(i.date))});let o=Array.from(P).sort();a&&(o=o.filter(e=>e<=a));for(const e of c)u.set(e.id,new Map);for(let e=0;e<o.length;e++){const i=o[e],s=e>0?o[e-1]:null,r=new Map;for(const y of c){const h=R(y.picks,d);let b=0;for(const A of h){const S=f.get(A)?.find(v=>v.date===i);S&&(b+=S.points)}r.set(y.id,b)}const m=w.get(i)??{};for(const y of c){const h=u.get(y.id),b=s?h.get(s)??0:0,A=r.get(y.id)??0,S=m[y.id]??0;h.set(i,b+A+S)}}return u}async function yt(t,a,n,c,d){const u=n.length;if(u<2)return[];const g=await L(M(l,k,t,"scoring")),f=new Map,p=new Set;for(const o of n){const e=o.picks?.bombPick;e&&o.id!==a&&p.add(e)}if(p.size===0)return[];const w=new Map;for(const o of p)try{const e=await N(o),i=new Map;for(const s of e)s.date&&(!d||s.date<=d)&&i.set(s.date,s.dailyPoints??0);w.set(o,i)}catch{}const P=u-1;for(const o of g.docs){const e=o.data(),i=e.date??o.id;if(d&&i>d)continue;const s=e.bombThreshold??0;if(!(s<=0))for(const r of n){if(r.id===a)continue;const m=r.picks?.bombPick;if(!m)continue;const y=w.get(m)?.get(i)??0,h=Math.max(0,s-y);if(h<=0)continue;const b=h/P,A=`${r.id}:${m}`,S=f.get(A);S?S.damage-=b:f.set(A,{gameId:m,pickerTeamName:r.name,damage:-b})}}return Array.from(f.values()).filter(o=>o.damage<0).map(o=>({gameId:o.gameId,gameName:c[o.gameId]?.name??"Unknown",pickerTeamName:o.pickerTeamName,damage:o.damage})).sort((o,e)=>o.damage-e.damage)}async function ht(t,a,n,c){const d=a.length;if(d<2)return{};const u=await L(M(l,k,t,"scoring")),g=new Map;a.forEach(o=>g.set(o.id,new Map));const f=new Set;for(const o of a){const e=o.picks?.bombPick;e&&f.add(e)}if(f.size===0)return{};const p=new Map;for(const o of f)try{const e=await N(o),i=new Map;for(const s of e)s.date&&(!c||s.date<=c)&&i.set(s.date,s.dailyPoints??0);p.set(o,i)}catch{}const w=d-1;for(const o of u.docs){const e=o.data(),i=e.date??o.id;if(c&&i>c)continue;const s=e.bombThreshold??0;if(!(s<=0))for(const r of a){const m=r.picks?.bombPick;if(!m)continue;const y=p.get(m)?.get(i)??0,h=Math.max(0,s-y);if(h<=0)continue;const b=h/w;for(const A of a){if(A.id===r.id)continue;const S=`${r.id}:${m}`,v=g.get(A.id),C=v.get(S);C?C.damage-=b:v.set(S,{gameId:m,pickerTeamName:r.name,damage:-b})}}}const P={};for(const o of a){const e=Array.from(g.get(o.id).values()).filter(i=>i.damage<0).map(i=>({gameId:i.gameId,gameName:n[i.gameId]?.name??"Unknown",pickerTeamName:i.pickerTeamName,damage:i.damage})).sort((i,s)=>i.damage-s.damage);P[o.id]=e}return P}const ot="seasonResults";function K(t,a){return E(l,k,t,ot,a)}async function ct(t,a){const n=await T(K(t,a));return n.exists()?n.data():null}async function it(t,a){const n=Q(a),c=await nt(t,n),d=await q(t),u=new Set;c.forEach(s=>{s.forEach((r,m)=>u.add(m))});const g=Array.from(u).sort(),f={};for(const s of d){const r=c.get(s.id),m=g[g.length-1];f[s.id]=m&&r?r.get(m)??0:0}const p=[...d].sort((s,r)=>(f[r.id]??0)-(f[s.id]??0)),w={};p.forEach((s,r)=>{w[s.id]=r+1});const P=p.map(s=>({teamId:s.id,data:g.map(r=>c.get(s.id)?.get(r)??0)})),o={finalScores:f,finalRanks:w,graphData:{dates:g,series:P},computedAt:B()},e=K(t,a),i=await T(e);return i.exists()?i.data():(await j(e,{...o,computedAt:B()}),(await T(e)).data())}async function bt(t,a){const n=await ct(t,a);return n||it(t,a)}export{st as L,x as a,lt as b,gt as c,X as d,mt as e,at as f,Z as g,q as h,bt as i,pt as j,nt as k,yt as l,ht as m,wt as n,ut as s,O as t};
